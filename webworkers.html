<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
<title>Web Workers - Dive Into Unicorn Magic âœ¨ğŸ¦„</title>
<link rel="stylesheet" href="unicorn-style.css">
<style>
h1:before{content:"Worker Magic: "}
</style>
</head>
<body>

<p>ğŸ¦„ You are here: <a href="index.html">Unicorn Home</a> <span class="u">âœ¨</span> <a href="index.html">Dive Into Unicorn Magic</a> <span class="u">âœ¨</span></p>

<h1><br>Multitasking Unicorns: Web Workers</h1>

<p class="a">ğŸŒŸ âœ¨ ğŸŒˆ</p>

<p class="f"><span style="font-size:4em;float:left;line-height:0.8;margin:0.1em 0.2em 0 0;background:linear-gradient(45deg,#ffd700,#ff69b4,#87ceeb,#9b59b6);-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-weight:bold;">I</span>magine having multiple unicorns working on different tasks at the same time! That's exactly what <strong>Web Workers</strong> do â€” they let you run JavaScript in background threads, keeping your magical interface smooth and responsive even while performing heavy computations!</p>

<h2>ğŸ§µ What Are Web Workers?</h2>

<p>Web Workers allow you to run JavaScript in background threads, separate from the main execution thread. This means you can perform expensive operations without blocking the UI!</p>

<p><strong>Why use Workers?</strong></p>
<ul style="list-style:disc;padding-left:2em;">
<li style="margin:0.5em 0;">Keep UI responsive during heavy calculations</li>
<li style="margin:0.5em 0;">Process large amounts of data without freezing</li>
<li style="margin:0.5em 0;">Perform background tasks (image processing, data parsing)</li>
<li style="margin:0.5em 0;">True parallel processing on multi-core CPUs</li>
</ul>

<h2>ğŸ¯ Creating Your First Worker (2025 Style)</h2>

<p><strong>Main thread (your page):</strong></p>
<pre><code>// Create a worker
const worker = new Worker('unicorn-worker.js');

// Send data to worker
worker.postMessage({ 
  task: 'calculateRainbows',
  count: 1000000 
});

// Receive results from worker
worker.addEventListener('message', (e) => {
  console.log('Worker says:', e.data);
  document.getElementById('result').textContent = e.data.result;
});

// Handle errors
worker.addEventListener('error', (e) => {
  console.error('Worker error:', e.message);
});

// Terminate worker when done (important!)
function cleanup() {
  worker.terminate();
}</code></pre>

<p><strong>Worker file (unicorn-worker.js):</strong></p>
<pre><code>// This runs in a separate thread!
self.addEventListener('message', (e) => {
  const { task, count } = e.data;
  
  if (task === 'calculateRainbows') {
    // Perform heavy calculation
    let result = 0;
    for (let i = 0; i < count; i++) {
      result += Math.sqrt(i) * Math.PI;
    }
    
    // Send result back to main thread
    self.postMessage({ 
      result: result,
      status: 'complete'
    });
  }
});</code></pre>

<h2>ğŸ’¬ Communication Patterns</h2>

<h3>Simple Message Passing</h3>
<pre><code>// Main â†’ Worker
worker.postMessage('Hello unicorn!');

// Worker â†’ Main
self.postMessage('Hello back from worker!');</code></pre>

<h3>Structured Data</h3>
<pre><code>// Send complex objects (automatically cloned)
worker.postMessage({
  unicorns: [
    { name: 'Sparkles', power: 9000 },
    { name: 'Rainbow', power: 8500 }
  ],
  timestamp: Date.now()
});

// Worker receives exact copy
self.addEventListener('message', (e) => {
  const { unicorns, timestamp } = e.data;
  console.log('Processing', unicorns.length, 'unicorns');
});</code></pre>

<h3>Transferable Objects (Zero-Copy!)</h3>
<pre><code>// For large data (ArrayBuffers), use transfer for performance
const buffer = new ArrayBuffer(1024 * 1024); // 1MB
const view = new Uint8Array(buffer);
view[0] = 42;

// Transfer ownership (zero-copy, super fast!)
worker.postMessage({ buffer }, [buffer]);

// buffer is now unusable in main thread (transferred!)
console.log(buffer.byteLength); // 0 (detached)</code></pre>

<h2>ğŸ¨ Practical Examples</h2>

<h3>Image Processing Worker</h3>
<pre><code>// Main: Send image data to worker
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

worker.postMessage({
  cmd: 'applyFilter',
  imageData: imageData
}, [imageData.data.buffer]); // Transfer for performance

worker.onmessage = (e) => {
  ctx.putImageData(e.data.imageData, 0, 0);
};

// Worker: Process pixels
self.addEventListener('message', (e) => {
  const { cmd, imageData } = e.data;
  
  if (cmd === 'applyFilter') {
    const data = imageData.data;
    
    // Apply unicorn magic filter (make it purple!)
    for (let i = 0; i < data.length; i += 4) {
      data[i] = data[i] * 0.8;     // Reduce red
      data[i+1] = data[i+1] * 0.6; // Reduce green
      data[i+2] = data[i+2] * 1.3; // Boost blue
    }
    
    self.postMessage({ imageData }, [imageData.data.buffer]);
  }
});</code></pre>

<h3>Data Processing Worker</h3>
<pre><code>// Main: Process large JSON data
fetch('/api/unicorns')
  .then(r => r.json())
  .then(data => {
    worker.postMessage({
      cmd: 'analyze',
      data: data
    });
  });

worker.onmessage = (e) => {
  const { stats } = e.data;
  displayStats(stats);
};

// Worker: Crunch numbers
self.addEventListener('message', (e) => {
  const { cmd, data } = e.data;
  
  if (cmd === 'analyze') {
    const stats = {
      total: data.length,
      avgPower: data.reduce((sum, u) => sum + u.power, 0) / data.length,
      maxPower: Math.max(...data.map(u => u.power)),
      topUnicorns: data.sort((a,b) => b.power - a.power).slice(0, 10)
    };
    
    self.postMessage({ stats });
  }
});</code></pre>

<h2>ğŸ†• Shared Workers (Advanced)</h2>

<p>Shared Workers can be accessed by multiple scripts/tabs!</p>

<pre><code>// Create shared worker
const sharedWorker = new SharedWorker('shared-worker.js');

// Communicate via port
sharedWorker.port.start();
sharedWorker.port.postMessage('Hello from tab!');
sharedWorker.port.onmessage = (e) => {
  console.log('Shared worker says:', e.data);
};

// In shared-worker.js
self.addEventListener('connect', (e) => {
  const port = e.ports[0];
  
  port.addEventListener('message', (e) => {
    console.log('Message from tab:', e.data);
    port.postMessage('Reply from shared worker');
  });
  
  port.start();
});</code></pre>

<h2>âš™ï¸ Worker Capabilities & Limitations</h2>

<p><strong>âœ… Workers CAN use:</strong></p>
<ul style="list-style:disc;padding-left:2em;">
<li style="margin:0.5em 0;">JavaScript (ES6+, async/await, etc.)</li>
<li style="margin:0.5em 0;">XMLHttpRequest / Fetch API</li>
<li style="margin:0.5em 0;">WebSockets</li>
<li style="margin:0.5em 0;">IndexedDB</li>
<li style="margin:0.5em 0;">Timers (setTimeout, setInterval)</li>
<li style="margin:0.5em 0;">Import other scripts (<code>importScripts()</code>)</li>
<li style="margin:0.5em 0;">Create other workers (sub-workers!)</li>
</ul>

<p><strong>âŒ Workers CANNOT access:</strong></p>
<ul style="list-style:disc;padding-left:2em;">
<li style="margin:0.5em 0;">DOM (no document, no window)</li>
<li style="margin:0.5em 0;">Parent page's variables directly</li>
<li style="margin:0.5em 0;">Some browser APIs (no alert, no localStorage)</li>
</ul>

<h2>ğŸš€ Modern Worker Features (2025)</h2>

<h3>ES Modules in Workers</h3>
<pre><code>// Create worker with module support
const worker = new Worker('worker.js', { type: 'module' });

// In worker.js - use ES6 imports!
import { processData } from './utils.js';

self.addEventListener('message', async (e) => {
  const result = await processData(e.data);
  self.postMessage(result);
});</code></pre>

<h3>OffscreenCanvas (Render in Worker!)</h3>
<pre><code>// Main thread - transfer canvas to worker
const canvas = document.getElementById('myCanvas');
const offscreen = canvas.transferControlToOffscreen();

const worker = new Worker('canvas-worker.js');
worker.postMessage({ canvas: offscreen }, [offscreen]);

// Worker - draw without blocking UI!
self.addEventListener('message', (e) => {
  const canvas = e.data.canvas;
  const ctx = canvas.getContext('2d');
  
  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw complex animations here!
    ctx.fillRect(Math.random() * 300, Math.random() * 300, 50, 50);
    requestAnimationFrame(animate);
  }
  animate();
});</code></pre>

<h2>ğŸ’¡ 2025 Best Practices</h2>

<ol style="list-style:decimal;padding-left:2em;">
<li style="margin:1em 0;"><strong>Use for CPU-intensive tasks</strong> â€” Not for simple operations</li>
<li style="margin:1em 0;"><strong>Always terminate</strong> â€” Call <code>worker.terminate()</code> when done</li>
<li style="margin:1em 0;"><strong>Transfer, don't copy</strong> â€” Use Transferable Objects for large data</li>
<li style="margin:1em 0;"><strong>Handle errors</strong> â€” Always add error listeners</li>
<li style="margin:1em 0;"><strong>Use modules</strong> â€” Modern workers support ES6 modules</li>
<li style="margin:1em 0;"><strong>Pool workers</strong> â€” Reuse workers for multiple tasks</li>
<li style="margin:1em 0;"><strong>Profile first</strong> â€” Measure before optimizing with workers</li>
</ol>

<h3>Worker Pool Pattern</h3>
<pre><code>class WorkerPool {
  constructor(workerScript, poolSize = 4) {
    this.workers = [];
    this.taskQueue = [];
    
    for (let i = 0; i < poolSize; i++) {
      this.workers.push({
        worker: new Worker(workerScript),
        busy: false
      });
    }
  }
  
  async execute(data) {
    return new Promise((resolve, reject) => {
      const task = { data, resolve, reject };
      const available = this.workers.find(w => !w.busy);
      
      if (available) {
        this.runTask(available, task);
      } else {
        this.taskQueue.push(task);
      }
    });
  }
  
  runTask(workerObj, task) {
    workerObj.busy = true;
    
    const handler = (e) => {
      workerObj.worker.removeEventListener('message', handler);
      workerObj.busy = false;
      task.resolve(e.data);
      
      // Process next queued task
      if (this.taskQueue.length > 0) {
        this.runTask(workerObj, this.taskQueue.shift());
      }
    };
    
    workerObj.worker.addEventListener('message', handler);
    workerObj.worker.postMessage(task.data);
  }
  
  terminate() {
    this.workers.forEach(w => w.worker.terminate());
  }
}

// Usage
const pool = new WorkerPool('worker.js', 4);
const result = await pool.execute({ task: 'process', data: largeData });</code></pre>

<p class="a">ğŸŒŸ âœ¨ ğŸŒˆ</p>

<p><a href="websockets.html">Continue to WebSockets: Real-Time Unicorn Communication â†’</a></p>

<div class="pf">
<h4>ğŸ§µ 2025 Worker Wisdom ğŸ§µ</h4>
<div class="moneybags">
<p><strong>Universal Support:</strong> All modern browsers support Web Workers. Use them for CPU-intensive tasks to keep UI responsive!</p>
<p style="margin-top:1em;"><strong>When to use Workers:</strong></p>
<ul style="list-style:disc;padding-left:2em;margin-top:0.5em;">
<li>Image/video processing</li>
<li>Large data parsing (JSON, CSV)</li>
<li>Complex calculations (physics, cryptography)</li>
<li>Background data fetching and processing</li>
<li>Canvas rendering (with OffscreenCanvas)</li>
</ul>
<p style="margin-top:1em;"><strong>Modern features:</strong> ES modules, OffscreenCanvas, SharedArrayBuffer (with headers), and more!</p>
<p style="margin-top:1em;">ğŸ“š <strong>Resources:</strong> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" target="_blank" style="color:#9b59b6;font-weight:bold;">MDN Web Workers</a></p>
</div>
</div>

<p class="c">ğŸ¦„ Enchanted with Unicorn Magic ğŸ¦„<br>
<small style="opacity:0.7;">Modern web standards â€¢ Unicorn magic by Web Wizards</small></p>

<script src="j/jquery.js"></script>
<script src="j/dih5.js"></script>

</body>
</html>
